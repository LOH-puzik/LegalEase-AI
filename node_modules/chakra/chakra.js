var util = require('util'),
    EventEmitter = require('events').EventEmitter;

var CHANNEL_MSG_SENT = 'message:sent';
var CHANNEL_MSG_RECV = 'message:received';

// Chakra
// ======


// Chakra's are a concept from yoga that represent centers of premeating energy on the
// surface of the human body. This class provides a center for premeating messages as 
// an analogy for the Chakra.
//
// The `config` can be used to configure the Chakra and will be passed to the `configure`
// function.
function Chakra(config) {
    // Maximum number of Channels this Chakra accepts. -1 means unlimited.
    this.maxChannels = -1;

    // List of Channels connected to the Chakra
    this.channels = [];

    if (config) {
        this.configure(config);
    }
}

// Configure the Chakra. Possible options:
//
// - maxChannels -  The maximum number of channels the Chakra accepts
// - channels -     Channels that need to be connected to the Chakra
//
// returns the `Chakra` instance for a fluent interface.
Chakra.prototype.configure = function(config) {
    if (config.maxChannels || config.max) {
        this.maxChannels = config.maxChannels || config.max;
    }

    if (config.channels && Array.isArray(config.channels)) {
        var connect = this.connect, channels = this.channels;

        config.channels.forEach(function(channel) {
            if (-1 === channels.indexOf(channel)) {
                connect(channel);
            }
        });
    }

    return this;
};

// Connect a Channel to the Chakra. The `channel` will receive messages from the Chakra 
// and the Chakra will detect and transmit message from the `channel`.
//
// Returns the Chakra instance for a fluent interface.
Chakra.prototype.connect = function(channel) {
    // Check if the number of channels will not go over the maximum
    // and the channel is not in the list already
    if((-1 >= this.maxChannels || this.channels.length < this.maxChannels) && -1 === this.channels.indexOf(channel)) {
        var chakra = this;

        // Listen for sent messages
        channel.on(CHANNEL_MSG_SENT, function() {
            // Catch the message arguments
            var args = Array.prototype.slice.call(arguments, 0);

            // `origin` should be the first parameter for the dispatch method
            args.unshift(channel);

            // Transmit the message
            Chakra.prototype.transmit.apply(chakra, args);
        });

        // Add the channel to the list
        this.channels.push(channel);
    }

    return this;
};
// Alias for the `connect` function
Chakra.prototype.addChannel = Chakra.prototype.connect;

// Disconnect the `channel` from the Chakra. Returns the `Chakra` instance for a fluent interface.
Chakra.prototype.disconnect = function(channel) {
    var index;
    if (-1 !== (index = this.channels.indexOf(channel))) {
        this.channels.splice(index, 1);
    }

    return this;
};
// Alias for the `disconnect` function.
Chakra.prototype.removeChannel = Chakra.prototype.disconnect;

// Transmit a message to all connected channels. The Channel that the message
// orignated from is skipped
Chakra.prototype.transmit = function(origin/*, args... */) {
    // Gather arguments. Origin should be the first one
    // and is only for internal use
    var args = Array.prototype.slice.call(arguments, 1);

    // Pass the message to all channels except the origin
    this.channels.forEach(function(channel) {
        if (channel !== origin) {
            Channel.prototype.receive.apply(channel, args);
        }
    });

    return this;
};

// Channel
// =======

// Channels can receive message from one or multiple Chakras it is connected to and 
// send messages to the Chakra in order to have the message transmitted over other 
// Channels connected to the Chakra.
// A `config` object can be used to configure the Channel and will be passed to the 
// `configure` function.
function Channel(config) {
    EventEmitter.call(this);

    // Event emitter for message to separate message from the Channels events
    this.messages = new Vortex();
}
util.inherits(Channel, EventEmitter);

// Listen for `message`s send on the Channel and handle them in the `callback`.
Channel.prototype.listen = function(message, callback) {
    this.messages.on(message, callback);
};

// Ignore a `message` on the Channel that was previously listened for and handled by the
// `callback`
Channel.prototype.ignore = function(message, callback) {
    this.message.removeListener(message, callback);
};

// Receive a `message` on the Channel. This will trigger all listeners for the message.
// Returns the `Channel` instance for a fluent interface.
Channel.prototype.receive = function() {
    // Convert arguments map to an array
    var args = Array.prototype.slice.call(arguments, 0);

    // Emit an internal `CHANNEL_MSG_RECV` event
    this.emit.apply(this, [CHANNEL_MSG_RECV].concat(args));

    // Apply the args to the emit method of our Vortex
    this.messages.emit.apply(this.messages, args);

    return this;
};
// Alias for the `receive` function.
Channel.prototype.deliver = Channel.prototype.receive;

// Send a `message` over the Channel. This will be received by any Chakra this Channel
// is connected to.
Channel.prototype.send = function() {
    // Convert arguments map to an array
    var args = Array.prototype.slice.call(arguments, 0);

    // Add CHANNEL_MSG_SENT for internal processing
    args.unshift(CHANNEL_MSG_SENT);

    // Emit a `CHANNEL_MSG_SENT` event
    this.emit.apply(this, args);

    return this;
};

// Vortex
// ======

// Vortex is an extension of the standard EventEmitter and adds the option to set handlers
// for any event triggered.
function Vortex() {
    // List of handlers called for any event
    this._anyHandlers = [];

    // Call our prototype to set up
    EventEmitter.call(this);
}
util.inherits(Vortex, EventEmitter);

// Alter the emit method to include the registered onAny handlers
Vortex.prototype.emit = function() {
    var args = Array.prototype.slice.call(arguments, 0);

    // Call original emit
    EventEmitter.prototype.emit.apply(this, args);

    // Loop any handlers
    var handlers = this._anyHandlers.slice();
    for (var i = 0, l = handlers.length; i < l; i++) {
        handlers[i].apply(this, args);
    }
    return true;
};

// Register a handler that is called on any event emitted from the Vortex
Vortex.prototype.onAny = function(handler) {
    if ('function' !== typeof handler) {
        throw new Error('handler must be a Function');
    }

    this._anyHandlers.push(handler);
    return this;
};

// our awesome export products
exports = module.exports = {
    Chakra:  Chakra,
    Channel: Channel,
    Nadi:    Channel,
    Vortex:  Vortex
};
